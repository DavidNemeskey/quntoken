token {
    ANYCHAR;
    NEWLINE;
    TOKEN;
    PUNCT;
    WS;
}

define {
    // CHARACTERS CLASSES:
    SYMBOL              [: intersection( {BASE_CLASS}, \G{S} ) :]
    // punctuations (all):
    PUNCT               [: intersection( {BASE_CLASS}, \G{P} ) :]
    // joinable punctuations:
    SYMS                "&#x"("02c5"|"02ef"|"1f4b6"|"00a"[9e]|"00b"[239]|"02e"[123]|"02b"[01]|"2"[0-9ab][0-9a-f][0-9a-f])";"
    PUNCT_JOINABLE_CHAR [.?!~@#$%^*+=<>_¢¤§·×÷°,:;\-]
    PUNCT_JOINABLE      ({PUNCT_JOINABLE_CHAR}|"&ndash;"|"&mdash;"|{SYMS})

    // RULE FRAGMENTS
    // word token with dot:
    WORD                "."?({WORDCHAR2}+"."?)+
    WORD_IN_PAR         "("{WORD}")"
}



// M O D E S
start = PROGRAM;

// alap feldolgozas
mode PROGRAM : COMMON {
    {SNT_OPEN_QX}   {
        self_send1(TOKEN_ANYCHAR, Lexeme);
        self << INSNT;
    }
    {TAGGED_WS_SEQ} => TOKEN_WS(Lexeme);
}

// mondaton beluli feldolgozas
mode INSNT : COMMON {
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // whitespaces:
    {WSPACE}+ {
        std::wstring LEX(Lexeme);
        LEX = self.WS_OPEN_CPP + LEX + self.WS_CLOSE_CPP;
        self_send1(TOKEN_WS, LEX.c_str());
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // punctuations
    // joinable punctuations:
    {PUNCT_JOINABLE}+ {
        std::wstring LEX(Lexeme);
        LEX = self.PUNCT_OPEN_CPP + LEX + self.PUNCT_CLOSE_CPP;
        self_send1(TOKEN_PUNCT, LEX.c_str());
    }
    // other punctuations or symbols:
    {PUNCT}|{SYMBOL} {
        std::wstring LEX(Lexeme);
        LEX = self.PUNCT_OPEN_CPP + LEX + self.PUNCT_CLOSE_CPP;
        self_send1(TOKEN_PUNCT, LEX.c_str());
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // basic tokenizer rules:
    // - tokens can contain wordchars and dots, but dot can not follow another
    //   dot
    // - dot at the end of the word belongs to the sentence, if it is followed
    //   by a snt close tag
    // - words with parenthesis: (paren)thesis or paren(thesis), or
    //   par(en)thesis, but not (parenthesis)
    // verision for words with "-e" at sentence ending
    ((({WORD}?{WORD_IN_PAR})?{WORD})|({WORD}?{WORD_IN_PAR}))"-e."{SNT_CLOSE_QX} {
        std::wstring LEX(Lexeme);
        // delete dot and sentence close tag from the end of the Lexeme
        LEX.erase(LEX.end()-4, LEX.end());
        LEX = self.WORD_OPEN_CPP + LEX + self.WORD_CLOSE_CPP +
              self.WORD_OPEN_CPP + L"-e" + self.WORD_CLOSE_CPP +
              self.PUNCT_OPEN_CPP + L"." + self.PUNCT_CLOSE_CPP +
              self.SNT_CLOSE_CPP;
        self_send1(TOKEN_TOKEN, LEX.c_str());
        self << PROGRAM;
    }
    // verision for words with "-e"
    ((({WORD_IN_PAR})?{WORD})|({WORD}?{WORD_IN_PAR}{WORD}?))"-e" {
        std::wstring LEX(Lexeme);
        // delete "-e" from the end of the Lexeme
        LEX.erase(LEX.end()-2, LEX.end());
        LEX = self.WORD_OPEN_CPP + LEX + self.WORD_CLOSE_CPP +
              self.WORD_OPEN_CPP + L"-e" + self.WORD_CLOSE_CPP;
        self_send1(TOKEN_TOKEN, LEX.c_str());
    }
    // version for words at sentence endig:
    ({WORD}?{WORD_IN_PAR})?{WORD}"."{SNT_CLOSE_QX} {
        std::wstring LEX(Lexeme);
        // delete dot and sentence close tag from the end of the Lexeme
        LEX.erase(LEX.end()-2, LEX.end());
        LEX = self.WORD_OPEN_CPP + LEX + self.WORD_CLOSE_CPP +
              self.PUNCT_OPEN_CPP + L"." + self.PUNCT_CLOSE_CPP +
              self.SNT_CLOSE_CPP;
        self_send1(TOKEN_TOKEN, LEX.c_str());
        self << PROGRAM;
    }
    // version for other cases:
    (({WORD_IN_PAR})?{WORD})|({WORD}{WORD_IN_PAR}{WORD}?) {
        std::wstring LEX(Lexeme);
        LEX = self.WORD_OPEN_CPP + LEX + self.WORD_CLOSE_CPP;
        self_send1(TOKEN_TOKEN, LEX.c_str());
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // end of sentence: back to the basic mode (PROGRAM)
    {SNT_CLOSE_QX}   {
        self_send1(TOKEN_ANYCHAR, Lexeme);
        self << PROGRAM;
    }
}

// kozos dolgok
mode COMMON : <inheritable: only> {
    /* {NEWLINE}       => TOKEN_NEWLINE(Lexeme); */
    on_failure      => TOKEN_TERMINATION;
    /* on_failure      { */
    /*     std::wcout << L"HIBA: >>" << Lexeme << L"<<\n"; */
    /*     self_send1(TOKEN_ANYCHAR, Lexeme); */
    /* } */
    <<EOF>>         => TOKEN_TERMINATION;
}

// vim:set syntax=cpp:

